var documenterSearchIndex = {"docs":
[{"location":"#KangarooTwelve","page":"KangarooTwelve","title":"KangarooTwelve","text":"","category":"section"},{"location":"#Background","page":"KangarooTwelve","title":"Background","text":"","category":"section"},{"location":"","page":"KangarooTwelve","title":"KangarooTwelve","text":"A pure-Julia implementation of the KangarooTwelve hashing scheme, so named because it consists of 12 rounds of Keccak (TurboSHAKE128) with kangaroo hopping, allowing for parallel tree-ish hashing termed \"leaves stapled to a pole\".","category":"page"},{"location":"","page":"KangarooTwelve","title":"KangarooTwelve","text":"This scheme presents a particularly good balance of:","category":"page"},{"location":"","page":"KangarooTwelve","title":"KangarooTwelve","text":"Simplicity (Keccak + sponge + hopping)\nSecurity (128-bit)\nSpeed (up to ~2bytes/cycle)","category":"page"},{"location":"","page":"KangarooTwelve","title":"KangarooTwelve","text":"It is currently an IETF draft.","category":"page"},{"location":"#Usage","page":"KangarooTwelve","title":"Usage","text":"","category":"section"},{"location":"","page":"KangarooTwelve","title":"KangarooTwelve","text":"k12","category":"page"},{"location":"#KangarooTwelve.k12","page":"KangarooTwelve","title":"KangarooTwelve.k12","text":"k12(data::Union{IO, String, AbstractVector{Unsigned}}) -> UInt128\n\nHash data with the KangarooTwelve scheme.\n\nThis scheme presents a good balance of Simplicity, Security, and Speed.\n\nExtended help\n\nThe KangarooTwelve hashing scheme works by splitting the input data into n 8192-byte blocks (S₀, S₁, …, Sₙ₁) which are individually hashed with TurboSHAKE128 to produce 32-byte \"chaining values\" (CVs), which are put together and ingested to produce the final state.\n\n               ╭────╮ ╭────╮   ╭────╮ ╭────╮\n               │ S₁ │ │ S₂ │   │Sₙ₋₂│ │Sₙ₋₁│\n               ╰─┬──╯ ╰─┬──╯   ╰─┬──╯ ╰─┬──╯\n                 │110   │110     │110   │110\n                 ▼      ▼        ▼      ▼\n╭────────╮110⁶²╭─┴──╮ ╭─┴──╮   ╭─┴──╮ ╭─┴──╮\n│   S₀   ├─────┤ CV ├─┤ CV ├╴╍╶┤ CV ├─┤ CV ├─(n-1)(FFFF)(01)──▶─┤HASH│\n╰────────╯     ╰────╯ ╰────╯   ╰────╯ ╰────╯\n\nThis scheme has been described as \"leaves on a vine\". The hashing of blocks S₁ to Sₙ₁ is embarassingly parallel, and can be accelerated with both SIMD and multithreading.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/#Keccak","page":"Internals","title":"Keccak","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"KangarooTwelve.keccak_p1600","category":"page"},{"location":"internals/#KangarooTwelve.keccak_p1600","page":"Internals","title":"KangarooTwelve.keccak_p1600","text":"keccak_p1600(state::NTuple{25, UInt64}, ::Val{nrounds}=Val{12}())\n\nApply the Keccak-p[nrounds, 1600] permutation to state. This is formally defined in the Keccak reference  and formalised in FIPS 202.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Turboshake","page":"Internals","title":"Turboshake","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"KangarooTwelve.turboshake","category":"page"},{"location":"internals/#KangarooTwelve.turboshake","page":"Internals","title":"KangarooTwelve.turboshake","text":"turboshake(output::Type, message::AbstractVector{<:UInt8to64},\n           delimsuffix::UInt8=0x80, ::Val{capacity} = Val{256}())\n\nProduce an output (Unsigned or NTuple{n, <:Unsigned}) value, by performing TurboSHAKE on message with a certain capacity and delimsuffix.\n\nSee also: ingest, pad, squeeze.\n\n\n\n\n\n","category":"function"},{"location":"internals/#Sponge-and-Vine","page":"Internals","title":"Sponge & Vine","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"KangarooTwelve.Sponge\nKangarooTwelve.ByteSponge\nKangarooTwelve.GerminatingVine\nKangarooTwelve.Vine\nKangarooTwelve.ingest_length\nKangarooTwelve.finalise","category":"page"},{"location":"internals/#KangarooTwelve.Sponge","page":"Internals","title":"KangarooTwelve.Sponge","text":"Sponge{rate}\n\nA Keccak state that keeps track of the last lane updated.\n\nSee also: ingest, pad, and squeeze.\n\n\n\n\n\n","category":"type"},{"location":"internals/#KangarooTwelve.ByteSponge","page":"Internals","title":"KangarooTwelve.ByteSponge","text":"ByteSponge{rate}\n\nA Keccak state that keeps track of the last byte updated.\n\nSee also: ingest, pad, and squeeze.\n\n\n\n\n\n","category":"type"},{"location":"internals/#KangarooTwelve.GerminatingVine","page":"Internals","title":"KangarooTwelve.GerminatingVine","text":"GerminatingVine{rate}\n\nA vine that hasn't started to grow leaves yet (see the k12 docstring).\n\nSee also: Vine, ingest, ingest_length, finalise.\n\n\n\n\n\n","category":"type"},{"location":"internals/#KangarooTwelve.Vine","page":"Internals","title":"KangarooTwelve.Vine","text":"Vine{rate}\n\nA vine with leaves (see the k12 docstring).\n\nSee also: GerminatingVine, ingest, ingest_length, finalise.\n\n\n\n\n\n","category":"type"},{"location":"internals/#KangarooTwelve.ingest_length","page":"Internals","title":"KangarooTwelve.ingest_length","text":"ingest_length(accumulator::Union{<:ByteSponge, <:AbstractVine}, val::UInt, ::Val{bufsize}=Val{8}())\n\nIngest a right-encoded form of val into accumulator, allowing the encoding to be up to bufsize bytes.\n\n\n\n\n\n","category":"function"},{"location":"internals/#KangarooTwelve.finalise","page":"Internals","title":"KangarooTwelve.finalise","text":"finalise(vine::AbstractVine) -> ByteSponge\n\nFinalise vine by folding in the current leaf returning the padded trunk.\n\n\n\n\n\n","category":"function"},{"location":"internals/#State-operations","page":"Internals","title":"State operations","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"The ingest, pad, squeeze, and squeeze! are implemented for state tuples, sponges, and vines.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"KangarooTwelve.ingest\nKangarooTwelve.pad\nKangarooTwelve.squeeze\nKangarooTwelve.squeeze!","category":"page"},{"location":"internals/#KangarooTwelve.ingest","page":"Internals","title":"KangarooTwelve.ingest","text":"ingest(state::NTuple{25, UInt64}, block::NTuple{rate, UInt64})\n\nIngest a single block of input (with implied rate) into state or sponge.\n\nThe first rate elements of the state are xor'd block, and then the state is permuted with keccak_p1600.\n\n\n\n\n\ningest(state::NTuple{25, UInt64}, ::Val{capacity}, message::AbstractVector{<:Unsigned})\n\nIngest message into state, with the rate calculated based on capacity.\n\nThis breaks message into rate-sized blocks and then ingests them (as per ingest(state, ::NTuple{rate, UInt64})) in turn.\n\n\n\n\n\ningest(sponge::AbstractSponge, as::Type{<:Unsigned}, leaf::AbstractVector{<:Unsigned})\n\nIngest leaf into sponge by transforming it to an as via turboshake, and ingesting that result.\n\n\n\n\n\ningest(sponge::AbstractSponge, block::AbstractVector{<:Unsigned})\n\nIngest each element of block into sponge.\n\n\n\n\n\ningest(sponge::ByteSponge, x::Union{<:Unsigned, NTuple{N, <:Unsigned}})\n\nIngest x into sponge.\n\n\n\n\n\ningest(vine::AbstractVine, leaflet::AbstractVector{<:Unsigned})\ningest(vine::AbstractVine, x::Unsigned)\n\nIngest leaflet/x into vine, this may go into the leaves or the trunk depending on the vine type, and may cause the current leaf to be folded into the trunk, and a new leaf grown.\n\n\n\n\n\n","category":"function"},{"location":"internals/#KangarooTwelve.pad","page":"Internals","title":"KangarooTwelve.pad","text":"pad(state::NTuple{25, UInt64}, ::Val{capacity}, lastbyte::UInt, delimsuffix::UInt8)\n\nPerform \"padding\" of the lastbyte byte of state with delimsuffix.\n\nThis is the final modification to state in turboshake.\n\n\n\n\n\n","category":"function"},{"location":"internals/#KangarooTwelve.squeeze","page":"Internals","title":"KangarooTwelve.squeeze","text":"squeeze(outtype::Type, state::NTuple{25, UInt64}, ::Val{capacity})\n\nSqueeze an outtype out of state. outtype can be an Unsigned type or an unsigned NTuple.\n\n\n\n\n\nsqueeze(T::Type, sponge::AbstractSponge)\n\nSqueeze a T out of sponge.\n\n\n\n\n\n","category":"function"},{"location":"internals/#KangarooTwelve.squeeze!","page":"Internals","title":"KangarooTwelve.squeeze!","text":"squeeze!(output::Vector{UInt64}, state::NTuple{25, UInt64}, ::Val{capacity})\n\nSqueeze state into output.\n\n\n\n\n\nsqueeze!(output::Vector{UInt64}, sponge::AbstractSponge)\n\nSqueeze sponge into output.\n\n\n\n\n\n","category":"function"}]
}
